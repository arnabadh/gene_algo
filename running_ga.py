# -*- coding: utf-8 -*-
"""Running_GA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jtzoz9NxiAIJO7KN5qnpKXY5uFaKw80b
"""



import numpy as np
import random
import math 
import random

gen=0

maxgen=int(input("Enter number of maximum generation:"))
no_of_var=int(input("Enter number of independent variables:"))
N=int(input("Enter number of population:"))

x_max=[]
x_min=[]
length=[]
cumm_len=[]
cumm_len.append(0)
i=0
while i < no_of_var:
    temp1=float(input("Enter maximum value of x{}:".format(i+1)))
    temp2=float(input("Enter minimum value of x{}:".format(i+1)))

    if temp2>=temp1 :
        print("Incorrect range of x!")
        continue
    x_max.append(temp1)
    x_min.append(temp2)

    eps=float(input("Enter the value of accuracy:"))
    temp=math.ceil(math.log((x_max[-1]-x_min[-1])/eps)/math.log(2))
    length.append(temp)
    cumm_len.append(temp+cumm_len[-1])
    i=i+1


tot_bit=sum(length)
S=np.random.randint(0, 2, size=(N,tot_bit ))



    
while gen<maxgen:
    gen=gen+1
    
    #DECODED VALUE & 'x1,x2...' EVALUATION:: 

    decval_x=np.zeros((N,no_of_var))
    x=np.zeros((N,no_of_var))
    

    for i in range(N):
        for j in range(no_of_var):
            for k in range(0,length[j]):
                decval_x[i][j] = decval_x[i][j] + (2**(length[j]-k-1)) * S[i][k+cumm_len[j]]

    for i in range(N):
        for j in range(no_of_var):
            x[i][j] = x_min[j] + (x_max[j]-x_min[j])/(2**length[j]-1) * decval_x[i][j]
    
    print(x[np.argmax(fitness)])
    
    
    #FUNCTION DEFINITION:: 


    def function(x_arr):
        #type the function here
        #return x_arr[0]+x_arr[1]

        #dixon price function:
        return ( (x_arr[0]-1)**2 + 2* ( (2*x_arr[1]**2-x_arr[0])**2 ) )

        #rosenbrock function:
        #return ( 100*(x_arr[1]-x_arr[0]**2)**2 + (x_arr[0]-1)**2) 

        #himmelblau function:
        #return ( (x_arr[0]**2+x_arr[1]-11)**2 + (x_arr[0]+x_arr[1]**2-7)**2 ) 

        #return (x_arr[0]**3 * x_arr[1]**2) #+ constraint(x_arr)

    #FUNCTION OF CONSTRAINTS:: 


    #def constraint(x_arr):
      #g1=...
      #g2=...
    #return penalty(g1)+penalty(g2)
                                                                                              
    #def penalty(g):
      #if g<0:
        #return 0
      #else:
        #return g*g


        
    #FUNCTION CALLING & FITNESS EVALUATION::     


    funval=np.zeros(N)
    for i in range(N):
        funval[i]= function(x[i])

    fitness=np.zeros(N)
    #change the definition here
    fitness_eval = lambda param: (-1*param) 

    fitness = np.array(fitness_eval(funval))
    
    
    #BINARY TOURNAMENT SELECTION::  
    

    matpool = np.zeros( shape=(N,tot_bit) )
    j=0
    
    for m in range(2):
      indx=np.arange(N)
      np.random.shuffle(indx)
        
      for i in range(0,N,2):
        if(fitness[indx[i]]>fitness[indx[i+1]]):
            matpool[j]=S[indx[i]]
        else:
            matpool[j]=S[indx[i+1]]
        j=j+1
            
    

    #temp_x = x[np.argmax(fitness)]
    #temp_y = fitness(temp_x) 

    #if(temp_y > y_opti):
      #x_opti=temp_x
      #y_fitness=temp_y    
       
        
    #SINGLE POINT CROSSOVER::      
        
      

    for i in range(0,N,2):
            p1=np.random.randint(0, tot_bit)
            #p2=np.random.randint(0, tot_bit)
          

            #if p2>p1:
               # for j in range(p1,p2):
                   # matpool[i][j],matpool[i+1][j] = matpool[i+1][j],matpool[i][j]
           # else:
            for j in range(p1,tot_bit):
                matpool[i][j],matpool[i+1][j] = matpool[i+1][j],matpool[i][j]

    
        
                    
   #GLOBAL MUTATION::                 
                    
    pm=1/tot_bit
    for i in range(N):
        for j in range(tot_bit):
            probab=np.random.uniform(0,1)
            if(probab<pm):
                if(matpool[i][j]==0):
                    matpool[i][j]=1
                else:
                    matpool[i][j]=0
    
    
    
    S=matpool

ans=x[np.argmax(fitness)]
print("The value of independent variable where optimum lies: ",ans)
print("optimum function value is: ",function(ans))





